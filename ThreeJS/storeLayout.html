<!DOCTYPE html>

<html>

<head>
    <title> WebGL</title>
</head>
<body>

    <div id="my-webgl">
        <script src="libs/three.min.js"></script>
        <script src="libs/stats.js"></script>
        <script src="libs/dat.gui.js"></script>
        <script src="/libs/OrbitControls.js"></script>
        <script src="/libs/OBJLoader.js"></script>

    </div>

<script>

    var man;
    var floorSize = 1000;
    var wallHeight = 150;
    var cameraView = 2000;
    var grp1 = new THREE.Mesh();

    function orbitalControls(){
        orbitControls = new THREE.OrbitControls(camera);
        orbitControls.autoRotate = false;
        orbitControls.maxPolarAngle = Math.PI / 2;
        clock = new THREE.Clock();
    }

    function lightControls(){
        //add spotlight for a bit of light



        // add spotlight
        // spotLight = new THREE.SpotLight(0xffffff);
        // spotLight.position.set(-40, 60, -10);
        // spotLight.castShadow = true;
        // spotLight.shadow.camera.near = 2;
        // spotLight.shadow.camera.far = 200;
        // spotLight.shadow.camera.fov = 30;
        // spotLight.target = plane;
        // spotLight.distance = 100;
        // spotLight.angle = 0.4;


        var pointColor = "#ffffff"; //ccffcc
        // pointLight = new THREE.PointLight(pointColor);
        // pointLight.distance = 100;
        // pointLight.intensity = 3;
        // scene.add(pointLight);

        var x = floorSize/2 - 200, y = 80, z = floorSize/2 - 200, intensity = 2, distance = 200;

        var spotLight0 = new THREE.SpotLight(0xffffff);
        spotLight0.position.set(0,100,0);
        spotLight0.lookAt({x:0,y:0,z:0});
        spotLight0.distance = 1000;
        spotLight0.angle = 1;
        spotLight0.castShadow = true;
        scene.add(spotLight0);


        pointLight = new THREE.PointLight( 0xaabbcc, intensity, distance );
        pointLight.position.set( x, y, z );
        pointLight.castShadow = true;
        scene.add( pointLight );

        pointLight2 = new THREE.PointLight( 0xaabbcc, intensity, distance );
        pointLight2.position.set( x, y, -z );
        pointLight2.castShadow = true;
        scene.add( pointLight2 );

        pointLight3 = new THREE.PointLight( 0xaabbcc, intensity, distance );
        pointLight3.position.set( -x, y, z );
        pointLight3.castShadow = true;
        scene.add( pointLight3 );

        pointLight4 = new THREE.PointLight( 0xaabbcc, intensity, distance );
        pointLight4.position.set( -x, y, -z );
        pointLight4.castShadow = true;
        scene.add( pointLight4 );

        pointLight5 = new THREE.PointLight( 0xaabbcc, 5, 250 );
        pointLight5.position.set( 0, 100, 0 );
        pointLight5.castShadow = true;
        scene.add( pointLight5 );

        // add a small sphere simulating the pointlight
        var sphereLight = new THREE.SphereGeometry(0.2);
        var sphereLightMaterial = new THREE.MeshBasicMaterial({color: 0xac6c25});
        sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial);
        sphereLightMesh.castShadow = true;

        sphereLightMesh.position = new THREE.Vector3(3, 0, 3);
        scene.add(sphereLightMesh);

        var ambientLight = new THREE.AmbientLight(0x888888);
        scene.add(ambientLight);

    }

    function cameraControls(){

        // position and point the camera to the center of the scene
        camera.position.x = 280;
        camera.position.y = 350;
        camera.position.z = 650;
        camera.lookAt(scene.position);

    }

    function axisHelper(){
        var axes = new THREE.AxisHelper(500);
        scene.add(axes);
    }

    function constructWalls(){

        var onBeforeRender = function() {
            var v = new THREE.Vector3();
            return function onBeforeRender( renderer, scene, camera, geometry, material, group ) {
                // this is one way. adapt to your use case.
                if ( v.subVectors( camera.position, this.position ).dot( this.userData.normal ) > 0 ) {
                    geometry.setDrawRange( 0, 0 );
                }
            };
        }();

        var onAfterRender = function( renderer, scene, camera, geometry, material, group ) {
            geometry.setDrawRange( 0, Infinity );
        };

        var geometry = new THREE.BoxGeometry( floorSize, wallHeight, 0.25 );

        // material

        //learning-threejs/assets/textures/soil_specular.jpg
        var texture = THREE.ImageUtils.loadTexture('learning-threejs/assets/textures/general/stone-bump.jpg');
        var mat1 = new THREE.MeshPhongMaterial(
                {
                    color: 0xeeeeee,
                    specular: 0x050505,
                    shininess: 100
                });
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;

        // geom.computeVertexNormals();
        mat1.map = texture;


        var material = mat1//new THREE.MeshPhongMaterial( {color: 0xffffff} );
        //material.side = THREE.DoubleSide;

        // mesh
        mesh = new THREE.Mesh( geometry, material );
        mesh.position.set( 0, wallHeight/2, floorSize/2 );
        mesh.rotation.set( 0, 0, 0 );
        mesh.userData.normal = mesh.position.clone().normalize();
        //mesh.onBeforeRender = onBeforeRender;
        //mesh.onAfterRender = onAfterRender;
        scene.add( mesh );
        mesh.geometry.computeVertexNormals();


       mesh = new THREE.Mesh( geometry, material );
       mesh.position.set( 0, wallHeight/2, -floorSize/2 );
       mesh.rotation.set( 0, 0, 0 );
       mesh.userData.normal = mesh.position.clone().normalize();
       // mesh.onBeforeRender = onBeforeRender;
       // mesh.onAfterRender = onAfterRender;
       mesh.geometry.computeVertexNormals();
       scene.add( mesh );

       // mesh
       mesh = new THREE.Mesh( geometry, material );
       mesh.position.set( floorSize/2, wallHeight/2, 0 );
       mesh.rotation.set( 0, - Math.PI / 2, 0 );
       mesh.userData.normal = mesh.position.clone().normalize();
       mesh.geometry.computeVertexNormals();
       // mesh.onBeforeRender = onBeforeRender;
       // mesh.onAfterRender = onAfterRender;
       scene.add( mesh );

       // mesh
       mesh = new THREE.Mesh( geometry, material );
       mesh.position.set( - floorSize/2, wallHeight/2, 0 );
       mesh.rotation.set( 0, Math.PI / 2, 0 );
       mesh.userData.normal = mesh.position.clone().normalize();
       // mesh.onBeforeRender = onBeforeRender;
       // mesh.onAfterRender = onAfterRender;
       scene.add( mesh );

       // geometry
       var geometry = new THREE.BoxGeometry( floorSize, floorSize, 1 );

        //test1.jpg
        var texture = THREE.ImageUtils.loadTexture('images/floortile4.jpg');
        var mat = new THREE.MeshPhongMaterial({
            color: 0xeeeeee,
            specular: 0x050505,
            shininess: 100});
         texture.wrapS = THREE.RepeatWrapping;
         texture.wrapT = THREE.RepeatWrapping;

        // geom.computeVertexNormals();
        mat.map = texture;
        mat.map.repeat.set(4,4);
       // mesh - floor
        floorMesh = new THREE.Mesh( geometry, mat );
        floorMesh.position.set( 0, 0, 0 );
        floorMesh.rotation.set( - Math.PI / 2, 0, 0 );
        floorMesh.userData.normal = floorMesh.position.clone().normalize();
        floorMesh.receiveShadow = true;
       // mesh.onBeforeRender = onBeforeRender;
       // mesh.onAfterRender = onAfterRender;
       scene.add( floorMesh );
    }

    function initialSetup(){
        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xAAAAAA});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 10;
        plane.position.y = 0;
        plane.position.z = 0;

        // add the plane to the scene
        //scene.add(plane);

        // create a cube
        var cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
        var cubeMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.castShadow = true;

        // position the cube
        cube.position.x = -14;
        cube.position.y = 8;
        cube.position.z = 0;

        // add the cube to the scene
        scene.add(cube);

        var sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
        var sphereMaterial = new THREE.MeshPhongMaterial({color: 0x7777ff});
        sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

        // position the sphere
        sphere.position.x = 15;
        sphere.position.y = 4;
        sphere.position.z = 2;
        sphere.castShadow = true;

        // add the sphere to the scene
        scene.add(sphere);

    }

    function drawDoor(){
        loader = new THREE.OBJLoader();
        loader.load('Door/Door.obj', function (loadedMesh) {
            var material = new THREE.MeshLambertMaterial({color: 0xEE0000});

            // loadedMesh is a group of meshes. For
            // each mesh set the material, and compute the information
            // three.js needs for rendering.
            loadedMesh.children.forEach(function (child) {
                child.material = material;
                child.geometry.computeFaceNormals();
                child.geometry.computeVertexNormals();
            });

            mesh = loadedMesh.children[3];
            mesh.position.set(-160,0,-200);
            mesh.scale.set(.2, .2, .2);
            mesh.name = '4';
            //loadedMesh.rotation.x = -0.3;
            scene.add(mesh);

            mesh1 = loadedMesh.children[3];
            mesh1.name = '5';
            mesh1.position.set(-160,0,-199);
            mesh1.scale.set(.2,.2,.2);
            //loadedMesh.rotation.x = -0.3;
            scene.add(mesh1);
        });
    }

    function drawMan(){
        loader.load('man/stickman.OBJ', function (loadedMesh) {
            var material = new THREE.MeshLambertMaterial({color: 0x00FF00});

            // loadedMesh is a group of meshes. For
            // each mesh set the material, and compute the information
            // three.js needs for rendering.
            loadedMesh.children.forEach(function (child) {
                child.material = material;
                // child.geometry.computeFaceNormals();
                //  child.geometry.computeVertexNormals();
            });
            man = loadedMesh;
            loadedMesh.position.set(-0,18,-80);
           // loadedMesh.rotation.y = Math.PI/2;
            loadedMesh.rotation.x = Math.PI/2;
            //loadedMesh.rotation.z = Math.PI/2;
            loadedMesh.scale.set(.5,.4, .5);
            loadedMesh.material = material;
            scene.add(loadedMesh);
        });
    }

    function createMesh(geom, imageFile) {

        var texture = THREE.ImageUtils.loadTexture(imageFile);
        var mat = new THREE.MeshPhongMaterial();
         texture.wrapS = THREE.RepeatWrapping;
         texture.wrapT = THREE.RepeatWrapping;


       // geom.computeVertexNormals();
        mat.map = texture;
        //mat.map.repeat.set(5,5);

        geom.children.forEach(function (child) {
            if (child instanceof THREE.Mesh) {
                child.material = mat;
                child.geometry.computeFaceNormals();
                child.geometry.computeVertexNormals();
            }
        });
       // var mesh = new THREE.Mesh(geom, mat);
        geom.material = mat;
        return geom;
    }



    function draw2Tier(position, rotation){
        loader.load('2tier/Shelves.obj', function (loadedMesh) {
            var material = new THREE.MeshLambertMaterial({color: 0x0000FF});

            // loadedMesh is a group of meshes. For
            // each mesh set the material, and compute the information
            // three.js needs for rendering.

            var mesh = createMesh(loadedMesh, 'learning-threejs/assets/textures/general/wood-2.jpg');
            // loadedMesh.children.forEach(function (child) {
            //     child.material = material;
            //     // child.geometry.computeFaceNormals();
            //     //  child.geometry.computeVertexNormals();
            // });


            mesh.position.set(position.x, position.y, position.z);
            loadedMesh.rotation.y = Math.PI/2;
            //loadedMesh.rotation.x = Math.PI/2;
            //loadedMesh.rotation.z = Math.PI/2;
            mesh.scale.set(40, 18, 20);
            //loadedMesh.material = material;
            grp1.add(mesh);
            //scene.add(mesh);
        });
    }

    function drawShelf(){
        loader.load('shelf/shelf.obj', function (loadedMesh) {
            var mesh = createMesh(loadedMesh, 'learning-threejs/assets/textures/general/wood-2.jpg');
            mesh.position.set(100,-5,-15);
            mesh.rotation.y = -Math.PI/2;
            //loadedMesh.rotation.z = Math.PI/2;
            mesh.scale.set(2.5,.8,4);
            //loadedMesh.material = material;
            scene.add(mesh);
        });

    }

    function drawWindow(){
        loader.load('Window/Window.obj', function (loadedMesh) {
            var material = new THREE.MeshLambertMaterial({color: 0xFF0000});

            // loadedMesh is a group of meshes. For
            // each mesh set the material, and compute the information
            // three.js needs for rendering.
            loadedMesh.children.forEach(function (child) {
                child.material = material;
               // child.geometry.computeFaceNormals();
              //  child.geometry.computeVertexNormals();
            });

            loadedMesh.position.set(20,0,-69);
            //loadedMesh.scale.set(.8,.8, .8);
            loadedMesh.material = material;
            scene.add(loadedMesh);
        });
    }

    function drawSquareShelf(size, position){
        var lengthOffsetFrmCenter = 15;
        var widthOfsetFrmCenter = 8;
        for(var z = 0; z < size; z++){
            draw2Tier({x:-floorSize/2 + widthOfsetFrmCenter + position.x, y:15, z: 25*z - floorSize/2 + lengthOffsetFrmCenter + position.z});
            draw2Tier({x:-floorSize/2 + widthOfsetFrmCenter + position.x, y:33, z: 25*z - floorSize/2 + lengthOffsetFrmCenter + position.z});
        }
    }

    function drawRecCircle(position, radius){
        var lengthOffsetFrmCenter = 15;
        var widthOfsetFrmCenter = 8;
        var phase = 0;
        for(; phase < 2*Math.PI; phase+= Math.PI/2){
            draw2Tier({ x: -floorSize/2 + position.x + radius*Math.sin(phase),
                        y:15,
                        z: -floorSize/2 + position.z + radius*Math.cos(phase)});

            console.log(-floorSize/2 + position.x + radius*Math.sin(phase), -floorSize/2 + position.z + radius*Math.cos(phase))
        }
    }

    // once everything is loaded, we run our Three.js stuff.
    function initScene() {

        scene = new THREE.Scene();
        //scene.fog = new THREE.Fog(0xffffff, 1, 150);

        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, cameraView);

        // create a render and set the size
        renderer = new THREE.WebGLRenderer({antialias: true});

        renderer.setClearColor(new THREE.Color(0xEEEEEE));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        initialSetup();

        orbitalControls();

        constructWalls();

        cameraControls();

        lightControls();

        axisHelper();

        drawDoor();

        //drawWindow();

        drawMan();

        drawShelf();


        drawSquareShelf(4, {x:0,z:180});
        drawSquareShelf(4, {x:40,z:180});
        drawSquareShelf(4, {x:80,z:180});
        drawSquareShelf(4, {x:120,z:180});
        drawSquareShelf(4, {x:160,z:180});

        drawSquareShelf(4, {x:0,z:180});
        drawSquareShelf(4, {x:40,z:180});
        drawSquareShelf(4, {x:80,z:180});
        drawSquareShelf(4, {x:120,z:180});
        drawSquareShelf(4, {x:160,z:180});

        //drawRecCircle({x:200,z:200},50);
        scene.add(grp1);










        // add the output of the renderer to the html element
        document.getElementById("my-webgl").appendChild(renderer.domElement);

        // render the scene
        //renderer.render(scene, camera);

        // call the render function
        step = 0;
        phase = 0;

        stats = new Stats();
        stats.showPanel( 1 );
        document.body.appendChild( stats.dom );

        var gridHelper = new THREE.GridHelper( 400, 15 );
        gridHelper.position.set(0,1,0);
        //scene.add( gridHelper );

        controls();
        renderScene();
    }

    function controls(){
        controls = new function () {
            this.rotationSpeed = 0.02;
            this.bouncingSpeed = 0.03;
            this.lightRotSpeed = 0.000;
        };

        gui = new dat.GUI();
        gui.add(controls, 'rotationSpeed', 0, 0.5);
        gui.add(controls, 'bouncingSpeed', 0, 0.5);
        gui.add(controls, 'lightRotSpeed', 0.0, .25);
    }

    function renderScene() {
        //stats.update();
        // rotate the cube around its axes
        cube.rotation.x += controls.rotationSpeed;
        cube.rotation.y += controls.rotationSpeed;
        cube.rotation.z += controls.rotationSpeed;

        // bounce the sphere up and down
        step += controls.bouncingSpeed;
        sphere.position.x = 15 + (40 * (Math.cos(step)));
        sphere.position.y = 2 + (40 * Math.abs(Math.sin(step)));

        phase += (controls.lightRotSpeed > 0 ?.04: 0) + controls.lightRotSpeed;
        sphereLightMesh.position.z = 13 * (Math.sin(phase));
        sphereLightMesh.position.x = 13 * (Math.cos(phase));
        sphereLightMesh.position.y = 8;

        if(phase>0) {
            var xD = 195, yD = 30;
            var position = {
                z: xD * Math.sin(phase),
                x: xD * (Math.cos(phase)),
                y: yD
            };
            pointLight.position.copy(position);
            var position = {
                z: xD * Math.sin(phase + Math.PI / 2),
                x: xD * (Math.cos(phase + Math.PI / 2)),
                y: yD
            };
            pointLight2.position.copy(position);
            var position = {
                z: xD * Math.sin(phase + Math.PI),
                x: xD * (Math.cos(phase + Math.PI)),
                y: yD
            };
            pointLight3.position.copy(position);
            var position = {
                z: xD * Math.sin(phase + 3 * Math.PI / 2),
                x: xD * (Math.cos(phase + 3 * Math.PI / 2)),
                y: yD
            };
            pointLight4.position.copy(position);
        }
        var delta = clock.getDelta();
        orbitControls.update(delta);

        if(man != undefined){

             man.position.z = 160 * (Math.sin(phase));
             man.position.x = -160 * (Math.cos(phase));
             man.rotation.x = -phase;
             man.rotation.z = phase;
        }
       // camera.position.x = 80 * Math.cos(phase/4);
       // camera.position.z = 80 * Math.sin(phase/4);
       // camera.lookAt(scene.position);

        // render using requestAnimationFrame
        requestAnimationFrame(renderScene);
        renderer.render(scene, camera);
        stats.update();
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.onload = initScene;

    // listen to the resize events
    window.addEventListener('resize', onResize, false);

</script>
</body>
</html>